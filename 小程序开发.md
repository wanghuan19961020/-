### 小程序概览
#### 小程序开发主要分为三部分
- 页面布局：WXML，类似HTML
- 页面样式：WXSS，几乎就是CSS（某些不支持，某些进行了加强）
- 页面脚本：JavaScript+WXS，（JS，以及WeixinScript后续学习）
#### 小程序结构划分
- 最上层App -> 多个Page -> 多个组件
- 组件
  - 内置组件
  - 自定义组件
- App
  - app.js：创建App实例的代码以及一些全局相关的内容
  - app.json：全局的一些配置，比如window/tabbar等
  - app.wxss：全局的一些样式配置
- Page
  - page.js：创建Page实例的代码，以及页面相关的内容
  - page.json：业务单独的配置，比如页面对应的window配置，usingComponents
  - page.wxml：页面的wxml布局代码
  - page.wxss：页面的样式配置
- Component
  - component.js：创建component市里的代码，以及组件内部的内容
  - component.json：组件内部的配置，比如当前组件使用了别的组件
  - component.wxml：组件的wxml布局代码
  - component.wxss：组件的样式配置
#### 小程序初体验
1. 数据绑定
2. 列表渲染
3. 事件监听
```
<!--pages/home/home.wxml-->
<!-- 1.小程序的数据绑定: {{}} -> Mustache -->
<view>Hello {{name}}</view>
<view>我的年龄：{{age}}</view>

<!-- 2.列表展示: wx:for-->
<view wx:for="{{students}}">
  {{item.name}}--{{item.age}}
</view>

<!-- 3.事件监听改变data -->
<view>当前计数：{{counter}}</view>
<button size="mini" bindtap="handleBtnClick">+</button>
<button size="mini" bindtap="handleSubtraction">-</button>

```
```
// pages/home/home.js
Page({
  data: {
    name: 'Coderwhy',
    age: 18,
    students: [{
        id: 0,
        name: 'kobe',
        age: 30
      },
      {
        id: 1,
        name: 'james',
        age: 28
      },
      {
        id: 2,
        name: 'curry',
        age: 32
      },
      {
        id: 3,
        name: 'why',
        age: 18
      }
    ],
    counter: 0
  },
  handleBtnClick() {
    // 1.错误做法: 界面无法刷新
    // this.data.counter += 1
    // 2.this.setData()
    this.setData({
      counter: this.data.counter + 1
    })
  },
  handleSubtraction() {
    this.setData({
      counter: this.data.counter - 1
    })
  }
})
```
#### 小程序的MVVM架构
- Vue的MVVM和小程序的MVVM
  - Vue的MVVM
    - M: Model
    - V: View
    - VM: ViewModel
  
  ![](https://github.com/wanghuan19961020/study-notes/blob/master/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Vue%E7%9A%84MVVM%E6%A8%A1%E5%BC%8F.png)
  ```
  1. Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。
  2. ViewModel是Vue.js的核心，它是一个Vue实例。Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素。
  3. 当创建了ViewModel后，双向绑定是如何达成的呢？
    - 首先，我们将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关键。
    - 从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据；
    - 从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。
  ```
- 小程序的MVVM模式
  ![](https://github.com/wanghuan19961020/study-notes/blob/master/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84MVVM%E6%A8%A1%E5%BC%8F.png)
- MVVM为什么这么好用呢？
  - DOM Listeners：ViewModel层可以将DOM的监听绑定到Model层
  - Data Bindings：ViewModel层可以将数据的变量，响应式的反应到View层
- MVVM架构将我们从**命令式编程**转移到**声明式编程**
#### 小程序的配置
- 小程序的很多开发需求被规定到了配置文件中
- 为什么这样做呢？
  - 有利于开发效率
  - 可以保证开发出来的小程序的某些风格是比较一致的
  - 比如导航栏-顶部的TabBar，以及页面路由等等
- 常见的配置文件
  - project.config.json：项目配置文件，比如项目名称、appid等
    
    - https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html
  - sitemap.json
    
    - https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html
  - app.json：全局配置
    - https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html
    
      属性 | 类型 | 必填 | 描述
      ---|---|---|---|---
      **pages** | string[] | 是 | 页面路径列表
      **window** | Object | 否 | 全局的默认窗口表现
      **tabBar** | Object | 否 | 底部tab栏的实现
    - pages：页面路径类别
      - 用于指定小程序由那些页面组成，每一项都对应一个页面的路径信息
      - 小程序中所有的页面都是必须在pages中进行注册的
    - window：全局的默认窗口展示
      
      - 用户指定窗口如何展示
    - tabBar：顶部tab栏的展示
    ```
    {
      "pages": [
        "pages/home/home",
        "pages/about/about",
        "pages/profile/profile",
        "pages/category/category"
      ],
      "window": {
        "navigationBarBackgroundColor": "#ff5777",
        "navigationBarTextStyle": "white",
        "navigationBarTitleText": "购物街",
        "backgroundColor": "#eeeeee",
        "backgroundTextStyle": "light",
        "enablePullDownRefresh": false
      },
      "tabBar": {
        "selectedColor": "#ff5777",
        "list": [{
            "pagePath": "pages/home/home",
            "text": "首页",
            "iconPath": "assets/home.jpg",
            "selectedIconPath": "assets/home_select.jpg"
          },
          {
            "pagePath": "pages/category/category",
            "text": "分类",
            "iconPath": "assets/category.jpg",
            "selectedIconPath": "assets/category_select.jpg"
          }
        ]
      }
    }
    ```
  - page.json：页面配置
  ```
  {
    "usingComponents": {},
    "navigationBarTitleText": "商品分类",
    "navigationBarBackgroundColor": "#ff0000",
    "enablePullDownRefresh": true
  }
  ```
#### 小程序的双线程模型
- 小程序的宿主环境 --- 微信客户端
  - 宿主环境为了执行小程序的各种文件：wxml文件、wxss文件、js文件
  - 提供了小程序的双线程模型
  ![](https://github.com/wanghuan19961020/study-notes/blob/master/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png)
- 双线程模型
  - WXML模块和WXSS样式运行于渲染层，渲染层使用WebView线程渲染(一个程序有多个页面，会使用多个WebView的线程)
  - JS脚本(app.js/home.js等)运行于逻辑层，逻辑层使用JsCore运行JS脚本
  - 这两个线程都会经由微信客户端(Native)进行中转交互
- WXML --> JS对象 --> DOM树
- 数据发生变化：通过setData改变msg："Hello" -> "Bye"
  - 产生JS对象对应的节点就会发生变化
  - 对比前后两个JS对象得到变化的部分（diff算法）
  - 然后把这个差异应用到原来的Dom树上
  - 从而达到更新UI的目的，这就是数据驱动的原来
- 界面渲染整体流程
  1. 在渲染层，宿主环境会把WXML转化成对应的JS对象
  2. 将JS对象再次转成真实DOM树，交友渲染层线程渲染
  3. 数据变化时，逻辑层提供最新的变化数据，JS对象发生变化比较进行diff算法对比
  4. 将最新变化的内容反映到真实的DOM树中，更新UI
#### 小程序的启动流程
![](https://github.com/wanghuan19961020/study-notes/blob/master/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg)
- 注册小程序示例 
https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html

属性 | 类型 |	默认值 | 必填 |	说明| 最低版本
---|---|---|---|---|---
onLaunch | function |	| 否 | 生命周期回调——监听小程序初始化.
onShow	| function	| |	否 |生命周期回调——监听小程序启动或切前台。	
onHide	| function	| |	否 |生命周期回调——监听小程序切后台。	
onError	| function	| |	否 |错误监听函数。	
onPageNotFound | function	| | 否 | 页面不存在监听函数。| 1.9.90
onUnhandledRejection |	function	|	| 否 |	未处理的 Promise 拒绝事件监听函数。| 	2.10.0
其他| any	|	| 否 | 开发者可以添加任意的函数或数据变量到 Object 参数中，用 this 可以访问
```
// 注册一个小程序示例
App({
  // 生命周期函数
  /**
   * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）
   */
  onLaunch: function () {
    console.log('小程序初始化完成：onLaunch');
    setTimeout(function () {
      const err = new Error();
      throw err;
    }, 3000)
    // wx.getUserInfo({
    // 数据拿到之后，再进行回调
    //   success: (result) => {
    //     console.log(result);
    //   }
    // })
  },

  /**
   * 当小程序启动，或从后台进入前台显示，会触发 onShow
   * 小程序界面显示出来之后会执行的生命周期函数
   */
  onShow: function (options) {
    console.log('界面显示出来：onShow');
  },

  /**
   * 当小程序从前台进入后台，会触发 onHide
   * 小程序隐藏时会执行
   */
  onHide: function () {
    console.log('界面被隐藏时会执行：onHide');
  },

  /**
   * 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息
   */
  onError: function (msg) {
    console.log('小程序中发生一些错误时会执行');
  }
})
```
- 注册App时，我们需要做些什么？
  1. 判断小程序的进入场景
    - 小程序的打开场景：https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html
  2. 获取用户信息，并且获取用户信息之后，将其传递给服务器
  ```
  // app.js
  onShow: function (options) {
    // 1.判断小程序的进入场景
    console.log(options);
    switch(options.scene) {
      case 1001:
        break
      case 1005:
        break
    }
    // 2.获取用户信息，并且获取用户信息之后，将其传递给服务器
    wx.getUserInfo({
      success: function(res) {
        console.log(res);
      }
    })
  }
  ```
  ```
  // home.wxml
  <!-- 2.获取用户信息的方式 -->
  <button size="mini" 
    open-type="getUserInfo" 
    bindgetUserInfo="handleGetUserInfo"
  >
    获取授权
  </button>
  <!-- 3.展示用户信息的方式 -->
  <open-data type="userNickName"></open-data>
  <open-data type="userAvatarUrl"></open-data>
  ```
  ```
  // home.js
  Page({
    handleGetUserInfo(event) {
      console.log(event);
    }
  })
  ```
  3. 因为App()实例只有一个，并且是全局共享的(单例对象)，所以我们将一些共享数据放在这里
  ```
  // app.js
  App({
    globalData: {
      name: 'wh',
      age: 18
    }
  })
  ```
  ```
  // pages/home/home.js
  // getApp()获取App()产生的实例对象
  const app = getApp()
  console.log(app.globalData);
  const {name, age} = app.globalData
  console.log(name, age);
  ```
- 注册Page时做什么？
  - https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html
  ```
  // pages/home/home.js
  // getApp()获取App()产生的实例对象
  const app = getApp()
  console.log(app.globalData);
  const {name, age} = app.globalData
  console.log(name, age);
  // 注册一个页面
  // 页面也有自己的生命周期函数
  Page({
    // 2.初始化数据
    data: {
      msg: '哈哈哈'
    },
    // 3.监听wxml中相关的一些事件
    handleGetUserInfo(event) {
      console.log(event); 
    },
    // 1.监听页面的生命周期函数
    // 页面被加载出来
    onLoad() {
      console.log('onLoad');
    },
    // 页面初次渲染完成
    onReady() {
      console.log('onReady');
    },
    // 页面显示出来时
    onShow() {
      console.log('onShow');
    },
    // 页面隐藏起来时
    onHide() {
      console.log('onHide');
    },
    onUnload() {
      console.log('onUnload');
    },
    // 4.监听其他事件
    // 监听页面的滚动
    onPageScroll(obj) {
      console.log(obj);
    },
    // 监听页面滚动到底部
    onReachBottom() {
      console.log('页面滚动到底部');
    },
    // 下拉刷新
    onPullDownRefresh() {
      console.log('下拉刷新');
    }
  })
  ```
  1. 在生命周期函数中发送网络请求，从服务器获取数据
  2. 初始化一些数据，以方便被wxml引用展示
  3. 监听wxml中的事件，绑定对应的事件函数
  4. 其他一些监听（比如页面滚动、上拉刷新、下拉加载更多等）





- Page实例生命周期
![](https://github.com/wanghuan19961020/study-notes/blob/master/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Page%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg)
### 小程序常用内置组件
#### Text组件
- Text组件用于显示文本，类似于span标签，是行内元素

属性|类型|默认值|必填|说明|最低版本
---|---|---|---|---|---|
selectable|	boolean|	false|	否|	文本是否可选|	1.1.0
space|	string||		否|	显示连续空格|	1.4.0
decode|	boolean|	false|	否|	是否解码|	1.4.0
```
<!--pages/text/text.wxml-->
<!-- 1.基本使用 -->
<text>pages/text/text.wxml\n</text>
<text>你好小程序\n</text>

<!-- 2.selectable： true -->
<!-- 默认情况下text中的文本长安是不能选中的 -->
<text selectable="{{true}}">Hello Wh\n</text>
<text selectable>Hello Wh\n</text>

<!-- 3.space: 决定文本空格的大小 -->
<!-- ensp: 半个中文字符的大小-->
<!-- emsp: 一个中文字符的大小-->
<text>Hello World\n</text>
<text space="nbsp">Hello World\n</text>
<text space="ensp">Hello World\n</text>
<text space="emsp">Hello World\n</text>

<!-- 4.decode属性：是否解码文本-->
<text decode>5 &gt; 3</text>
```
#### Button组件
```
<!--pages/button/button.wxml-->
<text>pages/button/button.wxml</text>
<!-- 1.button的基本使用 -->
<button>按钮</button>

<!-- 2.size属性：mini -->
<button size="mini">按钮</button>
<button size="mini">按钮</button>

<!-- 3.type属性： -->
<button size="mini" type="primary">按钮</button>
<button size="mini" type="default">按钮</button>
<button size="mini" type="warn">按钮</button>

<!-- 4.palin：镂空效果 -->
<button size="mini" plain>按钮</button>

<!-- 5.disabled：不可用 -->
<button size="mini" disabled>按钮</button>

<!-- 6.loading -->
<button size="mini" loading="{{isLoading}}">按钮</button>

<!-- 7.hover-class -->
<button hover-class="pressed">按钮</button>
```
```
/* pages/button/button.wxss */
.pressed {
  background-color: red;
  color: white;
}
```
```
// pages/button/button.js
Page({
  /**
   * 页面的初始数据
   */
  data: {
    isLoading: true
  }
})
```
#### View组件
- 视图组件(块级元素，独占一行，通常用作容器组件)

属性|类型|默认值|必填|说明|最低版本
---|---|---|---|---|---|
hover-class|string|none|否|指定按下去的样式类。当 hover-class="none" 时，没有点击态效果|1.0.0
hover-stop-propagation|boolean|false|否|指定是否阻止本节点的祖先节点出现点击态|1.5.0
hover-start-time|number|50|否|按住后多久出现点击态，单位毫秒|1.0.0
hover-stay-time|number|400|否|手指松开后点击态保留时间，单位毫秒|1.0.0

```
<!--pages/view/view.wxml-->
<text>pages/view/view.wxml</text>
<!-- 1.view的基本使用 -->
<view class="box">哈哈哈</view>
<view>呵呵呵</view>

<!-- 2.hover-class: 当用户按下组件时，显示的样式 -->
<view class="box1" 
  hover-class="hover-view"
  hover-stay-time="{{0}}"
>
  box1
</view>

<!-- 3.hover-stop-propagation: 阻止祖先组件的点击态 -->
<view class="box2" hover-class="box2-hover">
  <view class="box1" 
    hover-class="hover-view"
    hover-stay-time="{{0}}"
    hover-stop-propagation
  >
    box1
  </view>
</view>
```
```
/* pages/view/view.wxss */
.box {
  background-color: violet;
}

.box1 {
  background-color: violet;
  width: 100px;
  height: 100px;
}

.hover-view {
  background-color: thistle;
  font-size: 30px;
}

.box2 {
  background-color: blue;
  width: 200px;
  height: 200px;
  margin-top: 20px;
}
.box2-hover {
  background-color: green;
}
```
#### Image组件
```
<!--pages/image/image.wxml-->
<text>pages/image/image.wxml</text>
<!-- 1.image的基本使用 -->
<!-- 
  重点：
    1.image组件可以写成单标签，也可以写成双标签
    2.image组件默认有自己的大小：320x240
    3.image组件是一个行内块级元素（inline-block）
 -->
<image />
<text>哈哈哈哈</text>
<image></image>
<text>呵呵呵呵</text>

 <!-- 2.src: 本地地址（相对路径|绝对路径）/远程地址 -->
<image src="../../assets/history_bgc.png" />
<image src="/assets/history_bgc.png" />
<image src="https://res.wx.qq.com/wxdoc/dist/assets/img/0.4cb08bb4.jpg" />

<!-- 补充：相册中的图片 -->
<button bindtap="handleChooseAlbum">选中图片</button>
<image src="{{imagePath}}"/>

<!-- 3.bindload: 监听图片加载完成; lazy-load: 图片懒加载，在即将进入一定范围（上下三屏）时才开始加载-->
<view>-----------------------------------</view>
<image wx:for="{{2}}" 
  src="https://res.wx.qq.com/wxdoc/dist/assets/img/0.4cb08bb4.jpg" 
  bindload="handleImageLoad"
  lazy-load
/>

<!-- 4.show-menu-by-longpress：开启长按图片显示识别小程序码菜单 -->
<image show-menu-by-longpress 
  src="https://res.wx.qq.com/wxdoc/dist/assets/img/0.4cb08bb4.jpg" />
```
```
// pages/image/image.js
Page({
  /**
   * 页面的初始数据
   */
  data: {
    imagePath: ''
  },
  handleChooseAlbum() {
    // 系统Api，让用户在相册中选择图片（或者图片）
    console.log('---------');
    wx.chooseImage({
      success: (res) => {
        console.log(res);  
        // 1.取出路径
        const path = res.tempFilePaths[0]
        // 2.设置imagePath
        this.setData({imagePath: path})
      },
    })    
  },
  handleImageLoad() {
    console.log('图片加载完成');
  }
})
```
#### Input组件
```
<!--pages/input/input.wxml-->
<text>pages/input/input.wxml</text>
<!-- 1.input基本使用 -->
<input />

<!-- 2.value: input中的默认值 -->
<input value="哈哈哈" />

<!-- 3.type: 决定键盘类型（英文字母+其他符号 | 数字 | 身份证） -->
<input type="number" />

<!-- 4.password：暗文 -->
<input password />

<!-- 5.placeholder：占位文字 -->
<input placeholder="请输入内容" />

<!-- 6.input绑定事件 -->
<input 
  bindinput="handleInput"
  bindblur="handleBlur"
  bindfocus="handleFocus"
/>
```
```
// pages/input/input.js
Page({
  handleInput(event) {
    console.log('用户输入内容：', event);
  },
  handleFocus(event) {
    console.log('input获得焦点：', event);
  },
  handleBlur(event) {
    console.log('input失去焦点：', event);
  }
})
```
```
/* pages/input/input.wxss */
input {
  border: 1px solid red;
  margin: 10px 30px;
}
```
#### scroll-view组件
- scroll-view组件可以实现局部滚动
```
<!--pages/scroll/scroll.wxml-->
<text>pages/scroll/scroll.wxml</text>
<!-- 1.水平滚动：scroll-x -->
<!-- view是块级元素 -->
<scroll-view class="container1" scroll-x>
	<view wx:for="{{10}}" class="item1">{{item}}</view>
</scroll-view>

<!-- 2.垂直滚动：scroll-y -->
<scroll-view class="container2" scroll-y>
	<view wx:for="{{10}}" class="item2">{{item}}</view>
</scroll-view>

<!-- 3.其他补充
  bindscroll: 滚动时触发;
  upper-threshold: 距顶部/左边多远时，触发 scrolltoupper 事件;
  bindscrolltoupper: 滚动到顶部/左边时触发;
  lower-threshold: 距底部/右边多远时，触发 scrolltolower 事件;
  bindscrolltolower: 滚动到底部/右边时触发.
 -->
<scroll-view 
  class="container2" 
  scroll-y
  bindscroll="handleScroll"
>
	<view wx:for="{{10}}" class="item2">{{item}}</view>
</scroll-view>
```
```
// pages/scroll/scroll.js
Page({
  handleScroll(event) {
    console.log('正在滚动：', event);
  }
})
```
```
/* pages/scroll/scroll.wxss */
.container1 {
  background: purple;
  white-space: nowrap;
}

.item1 {
  width: 100px;
  height: 100px;
  background: red;
  margin: 10px;
  display: inline-block;
}

.container2 {
  background: orange;
  height: 200px;
  margin-top: 20px;
}

.item2 {
  height: 100px;
  background: blue;
  margin: 10px;
}
```
#### 共同属性
属性名|类型|描述|注解
---|---|---|---|
id|String|组件唯一标识|整个页面唯一
class|String|组件的样式类|在对应的wxss中定义的样式类
style|String|组件的内联样式|可以动态的设置内联样式
hidden|Boolean|组件是否显示|所有组件默认显示
data-*|Any|自定义属性|组件上触发的事件时，会发送事件给事件处理函数
bind*/*catch|EventHandler|组件的事件|
### WXSS&WXML&WXS
#### WXSS页面样式写法
- 三种写法
  - 行内样式
  - 页面样式
  - 全局样式
- 优先级：行内样式 > 页面样式 > 全局样式
- 选择器

选择器|样例|样例描述
---|---|---|
.class|.intro|选择所有拥有class="intro"的组件
#id|#firstname|	选择拥有id="firstname"的组件
element|view|选择所有 view 组件
element, element|view, checkbox|选择所有文档的view组件和所有的checkbox组件
::after|view::after|在 view 组件后边插入内容
::before|view::before|在 view 组件前边插入内容
- 尺寸单位
  - rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。
  - 如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。

设备|rpx换算px (屏幕宽度/750)|px换算rpx (750/屏幕宽度)
---|---|---|
iPhone5|1rpx = 0.42px|1px = 2.34rpx
iPhone6|1rpx = 0.5px|1px = 2rpx
iPhone6 Plus|	1rpx = 0.552px|1px = 1.81rpx
- 样式导入
  - 使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。
- 官方样式库
  - https://github.com/Tencent/weui-wxss
```
<!--pages/wxss/wxss.wxml-->
<!-- 1.设置样式的三种方式 -->
<!-- 1.1.行内（内联）样式 -->
<view style="color: red; font-size: 32px;">哈哈哈</view>

<!-- 1.2.页内样式 -->
<view class="box">呵呵呵</view>

<!-- 1.3.全局样式 -->
<view class="container">嘿嘿嘿</view>

<!-- 2.三种样式作用于同一个组件 
  优先级：!important > 行内样式 > 页面样式 > 全局样式 -->
<view style="background: red;" class="content">嘻嘻嘻</view>

<!-- 3.wxss中的单位：rpx -->
<!-- 前端也需要进行尺寸的适配：em|rem|vw|vh -->
<view class="box1"></view>
<view class="box2"></view>

<view class="content1">哈哈哈</view>
<view class="content2">呵呵呵</view>
<button class="btn">按钮</button>

<!-- 4.使用官方的样式库开发一个搜索框 -->
<view class="weui-search-bar {{inputShowed ? 'weui-search-bar_focusing' : ''}}" id="searchBar">
	<form class="weui-search-bar__form">
		<view class="weui-search-bar__box">
			<i class="weui-icon-search"></i>
			<input type="text" class="weui-search-bar__input" placeholder="搜索" value="{{inputVal}}" focus="{{inputShowed}}" bindinput="inputTyping" />
			<span class="weui-icon-clear" wx:if="{{inputVal.length > 0}}" bindtap="clearInput"></span>
		</view>
		<label class="weui-search-bar__label" bindtap="showInput">
			<i class="weui-icon-search"></i>
			<span class="weui-search-bar__text">搜索</span>
		</label>
	</form>
	<view class="weui-search-bar__cancel-btn" bindtap="hideInput">取消</view>
</view>
```
```
/* pages/wxss/wxss.wxss */
@import './style/box.wxss';
@import './style/content.wxss';
@import './style/weui-searchbar.wxss';
.box {
  font-size: 32px;
  color: blue;
}
.content {
  background: purple;
}
```
```
// wxss.js
Page({
  data: {
      inputShowed: false,
      inputVal: ""
  },
  showInput: function () {
      this.setData({
          inputShowed: true
      });
  },
  hideInput: function () {
      this.setData({
          inputVal: "",
          inputShowed: false
      });
  },
  clearInput: function () {
      this.setData({
          inputVal: ""
      });
  },
  inputTyping: function (e) {
      this.setData({
          inputVal: e.detail.value
      });
  }
});
```
```
/* app.wxss */
@import './style/btn.wxss';
.container {
  font-size: 32px;
  color: green;
}
.content {
  background: orange;
}
```
#### WXML
##### WXML基本格式：
  - 类似于HTML代码：比如可以写成单标签，也可以写成双标签
  - 必须有严格的闭合：没有闭合会导致编译错误
  - 大小写敏感：class和Class是不同的属性
##### Mustache语法
```
<!--pages/wxml/wxml.wxml-->
<!-- 1.wxml的格式 -->
<!-- <view></view>
<image />
<input />
<view Class="" class=""></view> -->

<!-- 2.Mustache语法 -->
<view>{{msg}}</view>
<view>{{firstName}} {{lastName}}</view>
<view>{{firstName + ' ' + lastName}}</view>
<view>{{age >= 18 ? '成年人' : '未成年人'}}</view>
<view>{{nowTime}}</view>
<button size="mini" bindtap="handleSwicthColor">切换颜色</button>
<view class="box {{isActive ? 'active' : ''}}">哈哈哈</view>
```
```
/* pages/wxml/wxml.wxss */
.box {
  font-size: 64rpx;
}

.active {
  color: red;
}
```
```
// pages/wxml/wxml.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
    msg: '你好小程序',
    firstName: 'kobe',
    lastName: 'bryant',
    age: 12,
    nowTime: new Date().toLocaleString(),
    isActive: false
  },
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad() {
    setInterval(() => {
      this.setData({
        nowTime: new Date().toLocaleString()
      })
    })
  },
  handleSwicthColor() {
    console.log('---------');
    this.setData({
      isActive: !this.data.isActive
    })
  }
})
```
##### 逻辑判断：wx:if-wx:elif-wx:else
##### 逻辑判断补充：hidden属性
```
<!-- 3.条件判断 -->
<!-- wx:if/wx:elif/wx:else -->
<view>-----------条件判断--------------</view>
<button bindtap="handleSwitchShow">切换显示</button>
<view wx:if="{{isShow}}">哈哈哈哈</view>
<button bindtap="handleIncrement">分数递增</button>
<view>{{score}}</view>
<view wx:if="{{score >= 90}}">优秀</view>
<view wx:elif="{{score >= 80}}">良好</view>
<view wx:elif="{{score >= 60}}">及格</view>
<view wx:else>不及格</view>
<!-- 
  hidden属性
  w:if和hidden：
    区别：
      hidden：将一个组件隐藏起来时，该组件依然是存在（display：none）
      w:if：将一个组件隐藏起来市，该组件根本不存在（压根没有创建）
    选择：
      如果显示和隐藏切换的频率非常高，选择使用hidden
      如果显示和隐藏切换的频率非常低，选择使用w:if
 -->
<view hidden="{{false}}">我是hidden属性控制的内容</view>
<view wx:if="{{true}}">我是wx:if属性控制的内容</view>
```
```
// pages/wxml/wxml.js
Page({
  /**
   * 页面的初始数据
   */
  data: {
    msg: '你好小程序',
    firstName: 'kobe',
    lastName: 'bryant',
    age: 12,
    nowTime: new Date().toLocaleString(),
    isActive: false,
    isShow: true,
    score: 45
  },
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad() {
    setInterval(() => {
      this.setData({
        nowTime: new Date().toLocaleString()
      })
    })
  },
  handleSwicthColor() {
    this.setData({
      isActive: !this.data.isActive
    })
  },
  handleSwitchShow() {
    this.setData({
      isShow: !this.data.isShow
    })
  },
  handleIncrement() {
    this.setData({
      score: this.data.score + 5
    })
  }
})
```
##### 列表渲染-wx:for
```
<!-- 1.wx:for的回顾 -->
<!-- 1.1.遍历数组|字符串|数字 -->
<view wx:for="{{['abc', 'cba', 'nba']}}">{{item}} {{index}}</view>
<view wx:for="coderwhy">{{item}} {{index}}</view>
<view wx:for="{{9}}">{{item}}</view>
```
  - block标签
  ```
  <!-- block标签 -->
  <view>---------------block标签--------------</view>
  <block wx:if="{{isShow}}">
    <button>按钮</button>
    <view>呵呵呵</view>
    <text>我是内容</text>
  </block>
  <block wx:for="{{3}}">
    <button>按钮</button>
    <view>呵呵呵</view>
    <text>我是内容</text>
  </block>
  ```
    - 某些情况下，我们需要使用wx:if或wx:for时，可能需要包裹一组组件标签
    - 我们希望对一组组件标签进行整体的操作
      - 方式一：使用view组件包裹
      - 方式二：使用block标签
    - 注意：
      - `<block />`并不是一个组件，它仅仅是一个包装元素，不会在页面中作任何渲染，只接受控制属性
    - 使用`block`有两个好处：
      - 将需要进行遍历或者判断的内容进行包裹
      - 将遍历和判断的属性放在block标签中，不影响普通属性的阅读，提高代码可读性
  - item、index名称
    - 默认情况下，item - index的名字是固定的
      - 但在某些情况下，肯相使用其他名称
      - 或者当出现多层遍历时，名字会重复
      - 这个时候，我们可以指定item、index名称
  ```
  <!-- 3.item、index起名字 -->
  <view wx:for="{{movies}}" wx:for-item="movie" wx:for-index="i">{{movie}} {{i}}</view>
  <block wx:for="{{nums}}" wx:for-item="inner_item">
    <block wx:for="{{inner_item}}">
      <view>{{item}}</view>
    </block>
  </block>
  ```
  ```
  // pages/wxml/wxml.js
  Page({
    data: {
      movies: ['星际穿越', '盗梦空间', '大话西游'],
      nums: [
        [10, 14, 11, 18],
        [20, 24, 31, 48],
        [110, 124, 211, 318]
      ]
    }
  })
  ```
  - key作用
    - 提高性能（虚拟DOM）
    ![](https://github.com/wanghuan19961020/study-notes/blob/master/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/key%E7%9A%84%E4%BD%9C%E7%94%A8.jpg)
  ```
  <!-- 4.key的作用 -->
  <view class="container">
    <view wx:for="{{['a', 'b', 'c']}}" wx:key="item">{{item}}</view>
  </view>
  ```
##### 模板语法
- WXML提供模板(template)，可以在模板中定义代码片段，在不同的地方调用。(是一种wxml代码的复用机制)
- 使用name属性，作为模板的名字，然后在`<template/>`定义代码片段
```
<!-- 
  之前的时候小程序不支持自定义组件，为了进行代码的复用：template；
  模板中包裹的内容，在没有被使用前，是不会进行任何渲染的；
-->
 <template name="contentItem">
  <button size="mini">{{btnText}}</button>
  <view>{{content}}</view>
 </template>
<template is="contentItem" data="{{btnText: '按钮', content: '哈哈哈'}}"/>
<template is="contentItem" data="{{btnText: '警告', content: '呵呵呵'}}"/>
<template is="contentItem" data="{{btnText: '点击', content: '嘿嘿嘿'}}"/>
<template is="contentItem" data="{{btnText: '登陆', content: '嘻嘻嘻'}}"/>
```
##### wxml的引入
- 小程序wxml中提供了两种引入文件的方式：import & include
- import引入：import可以在该文件中使用目标文件定义的template
  - 注意：wxml中不能递归引入(也就是A引入了B的template，不会引入B中引入C的template)
- include可以将目标文件中除了`<template/> <wxs/>`外的整个代码引入，相当于拷贝到include位置
```
<import src="/wxml/template.wxml"/>
<template is="contentItem" data="{{btnText: '按钮', content: '哈哈哈'}}"/>
<template is="contentItem" data="{{btnText: '警告', content: '呵呵呵'}}"/>
<template is="contentItem" data="{{btnText: '点击', content: '嘿嘿嘿'}}"/>
<template is="contentItem" data="{{btnText: '登陆', content: '嘻嘻嘻'}}"/>
```
```
 <!-- /wxml/template.wxml -->
 <template name="contentItem">
 	<button size="mini">{{btnText}}</button>
 	<view>{{content}}</view>
 </template>
```
```
<!--pages/home/home.wxml-->
<include src="/wxml/header.wxml" />
<text class="title">Hello World</text>
<button>按钮</button>
<include src="/wxml/footer.wxml" />
```
```
<!--/wxml/header.wxml-->
<!-- <include src="/wxml/nav.wxml" /> -->
<view>
  <include src="/wxml/nav.wxml" />
  <view>标题</view>
</view>
```
```
<!--/wxml/nav.wxml-->
<view>导航</view>
```
```
<!--/wxml/footer.wxml-->
<view>
  <view>尾部</view>
  <view>版本说明</view>
</view>
```
#### WXS模块
##### 简介
- WXS（WeiXin Script）是小程序的一套基本语言，结合WXML，可以构建出页面的结构。
- 官方：WXS与JavaScript是不同的语言，有自己的语法，并不和JavaScript一致。（不过基本一致）
##### 为什么需要设计WXS语言？
- 在WXML中是不能直接调用Page/Component中定义的函数的
- 但是在某些情况，我们可以希望使用函数来处理WXML中的数据（类似于Vue中的过滤器），这时候就是用WXS了
##### WXS使用的限制和特点：
- WXS的运行环境和其他JavaScript代码是隔离的，WXS中不能调用其他JavaScript文件中定义的函数，也不能调用小程序提供的API
- WXS函数不能作为组件的事件回调
- 由于运行环境的差异，在IOS设备上小程序内的WXS会比JavaScript代码块2~20倍。在android设备上二者运行效率无差异
##### WXS的应用
```
// /wxs/info.wxs
// JS代码
var message = 'Hello World';
var name = "coderwhy";

var sum = function (num1, num2) {
  return num1 + num2;
}
// commonjs的模块化导出的写法
module.exports = {
  message: message,
  name: name,
  sum: sum
}
```
```
// /wxs/format.wxs
/**
 * 价格格式化
 * @param price 价格
 * @param number 保留小数位
 */
function priceFormat(price, number) {
  var number = number || 2;
  var f_price = parseFloat(price);
  return f_price.toFixed(number);
}
/**
 * 格式化日期
 * @param timestamp 时间戳
 * @param format 日期格式
 */
function dateFormat(timestamp, format) {
  if (!format) {
    format = "yyyy-MM-dd hh:mm:ss";
  }
  timestamp = parseInt(timestamp * 1000);
  var realDate = getDate(timestamp);
  function timeFormat(num) {
    return num < 10 ? '0' + num : num;
  }
  var date = [
    ["M+", timeFormat(realDate.getMonth() + 1)],
    ["d+", timeFormat(realDate.getDate())],
    ["h+", timeFormat(realDate.getHours())],
    ["m+", timeFormat(realDate.getMinutes())],
    ["s+", timeFormat(realDate.getSeconds())],
    ["q+", Math.floor((realDate.getMonth() + 3) / 3)],
    ["S+", realDate.getMilliseconds()],
  ];

  var regYear = getRegExp("(y+)", "i");
  var reg1 = regYear.exec(format);
  if (reg1) {
    format = format.replace(reg1[1], (realDate.getFullYear() + '').substring(4 - reg1[1].length));
  }
  for (var i = 0; i < date.length; i++) {
    var k = date[i][0];
    var v = date[i][1];

    var reg2 = getRegExp("(" + k + ")").exec(format);
    if (reg2) {
      format = format.replace(reg2[1], reg2[1].length == 1
        ? v : ("00" + v).substring(("" + v).length));
    }
  }
  return format;
}

module.exports = {
  priceFormat: priceFormat,
  dateFormat: dateFormat
}
```
```
<!--pages/wxs/wxs.wxml-->
<text>pages/wxs/wxs.wxml</text>
<!-- 1.错误的写法 -->
<!-- <view>{{25.66666666.toFixed(2)}}</view> -->
<!-- <view>{{numberToFixed(25.66666666)}}</view> -->
<!-- 
  2.wxs的定义方式
    2.1.直接在wxml中进行定义
  -->
<!-- <wxs module="info">
  // JS代码
  var message = 'Hello World';
  var name = "coderwhy";

  var sum = function(num1, num2) {
    return num1 + num2;
  }
  // commonjs的莫凯华导出的写法
  module.exports = {
    message: message,
    name: name,
    sum: sum
  }
 </wxs>
 <view>{{info.message}}</view>
 <view>{{info.name}}</view>
 <view>{{info.sum(20, 30)}}</view> -->

<!-- 2.2.定义在单独的wxs文件中，再使用<wxs>标签进行导入 -->
<!-- 不能使用绝对路径，必须使用相对路径 -->
<wxs src="../../wxs/info.wxs" module="info" /> 
<view>{{info.message}}</view>
<view>{{info.name}}</view>
<view>{{info.sum(20, 30)}}</view>

<!-- 3.wxs的应用 -->
<wxs src="../../wxs/format.wxs" module="format" /> 
<view>{{format.priceFormat(price, 4)}}</view>
<view>{{format.dateFormat(time, 'yyyy-MM-dd')}}</view>
```
```
// pages/wxs/wxs.js
Page({
  data: {
    price: 25.666666666,
    time: 15786786
  }
})
```
### 事件
#### 事件的介绍
- 什么时候会产生事件？
  - 小程序需要经常和用户进行某种交互，比如点击界面上的某个按钮或者区域，比如滑动了某个区域
  - 这些交互都会产生各种各样的事件
- 事件如何处理？
  - 事件是通过bind/catch这个属性绑定在组件上的(和普通的属性写法很相似，以key="value"形式)
  - key以bind或catch开头，从1.5.0版本开始，可以再bind和catch后加上一个冒号
  - 同时在当期页面的Page构造器中定义对应的事件处理函数tapName，如果没有对应的函数，触发事件时会报错
  - 当用户点击该button区域时，达到触发条件生成事件tap，改事件处理函数tapName会被执行，同时还会收到一个事件对象event
#### 常见事件类型
- 某些组件会有自己特有的事件类型，如input
- 常见事件类型

类型|触发条件|最低版本
---|---|---|
touchstart|手指触摸动作开始|	
touchmove|手指触摸后移动|	
touchcancel|手指触摸动作被打断，如来电提醒，弹窗|	
touchend|	手指触摸动作结束|	
tap|手指触摸后马上离开|	
longpress|手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发|	1.5.0
longtap|手指触摸后，超过350ms再离开（推荐使用longpress事件代替）|	
transitionend|会在 WXSS transition 或 wx.createAnimation 动画结束后触发|	
animationstart|会在一个 WXSS animation 动画开始时触发|	
animationiteration|会在一个 WXSS animation 一次迭代结束时触发|	
animationend|	会在一个 WXSS animation 动画完成时触发|	
touchforcechange|	在支持 3D Touch 的 iPhone 设备，重按时会触发|	1.9.90

```
<!--pages/home/home.wxml-->
<text class="title">Hello World</text>
<button>按钮</button>
<!-- 1.事件处理的回顾 -->
<button bindtap="handleBtnClick" size="mini">按钮</button>
<button bind:tap="handleBtnClick" size="mini">按钮</button>
<button catch:tap="handleBtnClick" size="mini">按钮</button>

<!-- 2.常见的一些事件 -->
<view
  class="box"
  bind:touchstart="handleTouchStart"
  bind:touchmove="handleTouchMove"
  bind:touchend="handleTouchEnd"
  bind:tap="handleTap"
  bind:longpress="handleLongPress"
>
</view>
```
```
// pages/home/home.js
Page({
  handleBtnClick() {
    console.log('按钮点击事件');
  },
  handleTouchStart() {
    console.log('handleTouchStart');
  },
  handleTouchMove() {
    console.log('handleTouchMove');
  },
  handleTouchEnd() {
    console.log('handleTouchEnd');
  },
  handleTap() {
    console.log('handleTap');
  },
  handleLongPress() {
    console.log('handleLongPress');
  }
})
```
#### 事件对象
属性|	类型|	说明|	基础库版本
---|---|---|---|
type|	String|	事件类型|	
timeStamp|	Integer|	事件生成时的时间戳|	
target|	Object|	触发事件的组件的一些属性值集合|	
currentTarget|	Object|	当前组件的一些属性值集合|	
mark|	Object|	事件标记数据|	2.7.1
detail|	Object|	额外的信息|
touches|	Array|	触摸事件，当前停留在屏幕中的触摸点信息的数组|
changedTouches|	Array|	触摸事件，当前变化的触摸点信息的数组|
##### touches和changedTouches的区别
- touches: 当前屏幕上所有触摸点的列表
- changedTouches：触发事件时改变的触摸点的集合
1. 在touchend中不同
2. 多手指触摸时不同
##### target和currentTarget的区别
- target：点击事件的组件
- currentTarget：触发事件的组件
##### 事件的传递参数
```
<!--pages/home/home.wxml-->
<!-- 4.事件的传递参数 -->
<view class="container">
  <block wx:for="{{titles}}" wx:key="index">
    <view 
      class="item" 
      bindtap="handleItemClick"
      data-index="{{index}}"
      data-item="{{item}}"
    >
      {{item}}
    </view>
  </block>
</view>
```
```
// pages/home/home.js
Page({
  data: {
    titles: ['衣服', '裤子', '鞋子']
  },
  handleItemClick(event) {
    console.log(event);
    const { item, index } = event.currentTarget.dataset
    console.log(item, index);
  }
})
```
##### 事件冒泡和事件捕获
- 当界面产生一个事件时，事件分为了捕获阶段和冒泡阶段
```
<!--pages/home/home.wxml-->
<!-- 5.事件冒泡和事件捕获 -->
<!-- bind: 一层层传递 -->
<!-- catch：阻止事件进一步传递 -->
<view 
  class="view1" 
  capture-bind:tap="handleCaptureView1"
  bindtap="handleBindView1"
>
  <view 
    class="view2"
    capture-bind:tap="handleCaptureView2"
    bindtap="handleBindView2"
  >
    <view 
      class="view3"
      capture-bind:tap="handleCaptureView3"
      bindtap="handleBindView3"
    ></view>
  </view>
</view>

<view 
  class="view1" 
  capture-bind:tap="handleCaptureView1"
  bindtap="handleBindView1"
>
  <view 
    class="view2"
    capture-catch:tap="handleCaptureView2"
    catchtap="handleBindView2"
  >
    <view 
      class="view3"
      capture-bind:tap="handleCaptureView3"
      bindtap="handleBindView3"
    ></view>
  </view>
</view>
```
```
// pages/home/home.js
Page({
  //-----事件冒泡和事件捕获----
  handleCaptureView1() {
    console.log('handleCaptureView1');
  },
  handleBindView1() {
    console.log('handleBindView1');
  },
  handleCaptureView2() {
    console.log('handleCaptureView2');
  },
  handleBindView2() {
    console.log('handleBindView2');
  },
  handleCaptureView3() {
    console.log('handleCaptureView3');
  },
  handleBindView3() {
    console.log('handleBindView3');
  },
})
```
### 组件化开发
#### 小程序组件化思想
- 从小程序基础库版本 1.6.3 开始，小程序支持简洁的组件化编程。所有自定义组件相关特性都需要基础库版本 1.6.3 或更高。
- 开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。
#### 创建一个自定义组件
- 类似于页面，一个自定义组件由 json wxml wxss js 4个文件组成
  - 习惯：在根目录下创建一个文件夹components，里面存放我们之后自定义的公共组件
  - 常见一个自定义组件my-cpn：包含对应的四个文件
- 自定义组件的步骤
  1. 首先需要在json文件中进行自定义组件的声明(将component字段设为true可这已组建文件设为自定义组件)
  ```
    {
      "component": true
    }
  ```
  2. 在wxml中编写组件模板
  ```
    <!-- 这是自定义组件的内部WXML结构 -->
    <view class="inner">
      {{innerText}}
    </view>
    <slot></slot>
  ```
  3. 在wxss中编写组件相关样式
  ```
    /* 这里的样式只应用于这个自定义组件 */
    .inner {
      color: red;
    }
  ```
  4. 在js文件中，可以定义数据或组件内部的相关逻辑
  ```
  Component({
    properties: {
      // 这里定义了innerText属性，属性值可以在组件使用时指定
      innerText: {
        type: String,
        value: 'default value',
      }
    },
    data: {
      // 这里是一些组件内部数据
      someData: {}
    },
    methods: {
      // 这里是一个自定义方法
      customMethod: function(){}
    }
  })
  ```
- 使用自定义组件
  - 使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径：
  ```
    {
      "usingComponents": {
        "component-tag-name": "path/to/the/custom/component"
      }
    }
  ```
- 细节：
  - 因为 WXML 节点标签名只能是**小写字母、中划线和下划线**的组合，所以自定义组件的标签名也只能包含这些字符。
  - 自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用 usingComponents 字段）。
  - 自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。
  - 如果在app.json的usingComponents声明某个组件，那么所有页面和组件可以直接使用该组件
#### 自定义组件的样式细节
##### 组件内的样式对外部样式的影响
- 组件内的class样式，只对组件wxml内的节点剩下，对于引用组件的Page页面不生效
- 组件内不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器
##### 外部样式对组件内样式的影响
- 外部样式使用class的样式，支队外部的wxml的class生效，对组件内是不生效的
- 外部使用了id选择器、属性选择器不会对组件内产生影响
- 外部使用了标签选择器，会对组件内产生影响
##### 整体结论
- 组件内的class样式和组件外的class样式，默认是有一个隔离效果的
- 为了防止样式的错乱，官方不推荐使用id、属性、标签选择器
  ```
    #a { } /* 在组件中不能使用 */
    [a] { } /* 在组件中不能使用 */
    button { } /* 在组件中不能使用 */
    .a > .b { } /* 除非 .a 是 view 组件节点，否则不一定会生效 */
  ```
##### class之间相互影响
- 在Component对象中，可以传入一个options属性，该属性中有一个styleIsolation（隔离）属性
  ```
    Component({
      options: {
        styleIsolation: 'isolated'
      }
    })
  ```
- styleIsolation 选项从基础库版本 2.6.5 开始支持。它支持以下取值：
  - isolated 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）；
  - apply-shared 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面；
  - shared 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 apply-shared 或 shared 的自定义组件。（这个选项在插件中不可用。）
- 官网参考：https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html
#### 组件和页面通信
##### 向组件建传递数据(properties)/样式(externalClasses)
```
<!--pages/home/home.wxml-->
<my-prop title="哈哈哈" titleclass="red" />
<my-prop title="呵呵呵" titleclass="green" />
<my-prop title="嘿嘿嘿" titleclass="blue" />
<my-prop />
```
```
/* pages/home/home.wxss */
.red {
  color: red;
}

.green {
  color: green;
}

.blue {
  color: blue;
}
```
```
<!--components/my-prop/my-prop.wxml-->
<view class="title titleclass">{{title}}</view>
<view class="content">我是组件内容</view>
```
```
// components/my-prop/my-prop.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    // title: String
    title: {
      type: String,
      value: '我是默认的标题',
      observer: function(newVal, oldVal) {
        console.log(newVal, oldVal);
      }
    }
  },
  externalClasses: ['titleclass']
})
```
##### 组件向外传递事件-自定义事件
```
<!--components/my-event/my-event.wxml-->
<button size="mini" bind:tap="handleIncrement">+1</button>
```
```
// components/my-event/my-event.js
Component({
  methods: {
    handleIncrement() {
      // console.log('----------');
      this.triggerEvent('increment', {name: 'why', age: 18}, {})
    }
  }
})
```
```
<!--pages/home/home.wxml-->
<!-- 4.组件内部发出事件 -->
<view>当前计数：{{counter}}</view>
<my-event bind:increment="handleIncrement"/>
```
```
// pages/home/home.js
Page({
  data: {
    counter: 0
  },
  handleIncrement(event) {
    console.log(event);
    this.setData({
      counter: this.data.counter + 1
    })
  }
})
```
##### 页面直接调用组件修改数据/方法
```
<!--components/my-sel/my-sel.wxml-->
<view>组件内的计数：{{counter}}</view>
```
```
// components/my-sel/my-sel.js
Component({
  data: {
    counter: 0
  },
  methods: {
    incrementCounter(num) {
      this.setData({
        counter: this.data.counter + num
      })
    }
  }
})
```
```
<!--pages/home/home.wxml-->
<!-- 6.直接选中组件修改数据/调用方法 -->
<button size="mini" bind:tap="handleIncrementCpn">修改组件内的数据</button>
<my-sel id="sel-id" class="sel-class" />
```
```
// pages/home/home.js
Page({
  handleIncrementCpn() {
    // 修改my-sel中的counter
    console.log('-----');
    // 1.获取组件对象
    const my_sel = this.selectComponent('.sel-class')
    // console.log(my_sel);
    // 2.通过setData修改组件中的数据（不推荐）
    // my_sel.setData({
    //   counter: my_sel.data.counter + 20
    // })
    // 3.通过方法对数据进行修改
    my_sel.incrementCounter(10)
  }
})
```
#### 插槽
##### 单个插槽的使用
```
<!--components/my-slot/my-slot.wxml-->
<view>我是组件的头部</view>
<slot />
<view>我是组件的尾部</view>
```
```
<!--pages/home/home.wxml-->
<!-- 7.插槽的使用 -->
<!-- 7.1.单个插槽的使用 -->
<my-slot>
	<button size="mini">我是插入的按钮</button>
</my-slot>
<my-slot>
	<text>哈哈哈哈哈</text>
</my-slot>
<my-slot>
	<image src="http://img4.imgtn.bdimg.com/it/u=1713396441,1487163637&fm=26&gp=0.jpg" />
</my-slot>
<my-slot>
	<slider value="60"></slider>
</my-slot>
```
##### 多个插槽的使用
```
<!--components/my-mslot/my-mslot.wxml-->
<view>我是mslot组件的开始</view>
<slot name="slot1"/>
<slot name="slot2"/>
<slot name="slot3"/>
<view>我是mslot组件的开始</view>
```
```
// components/my-mslot/my-mslot.js
Component({
  options: {
    multipleSlots: true
  }
})
```
```
<!--pages/home/home.wxml-->
<!-- 7.2.多个插槽的使用 -->
<!-- 
  注意事项：
    1.给每一个插槽起一个名字
    2.必须在Component对象中添加一个选项：options -> multipleSlots: true
 -->
<my-mslot>
	<button size="mini" slot="slot2">我是插入的按钮</button>
	<slider value="20" slot="slot1"></slider>
  <text slot="slot3">哈哈哈哈哈</text>
</my-mslot>
```
#### Component构造器
##### 常用属性
```
Component({
  // ------- 让使用者可以传入数据 ---------
  properties: {

  },
  // ------- 定义组件内部的初始化数据 ---------
  data: {
    counter: 0
  },
  // ------- 用于定义组件内部的函数 ---------
  methods: {

  },
  // ------- 定义组件的配置选项 ---------
  // multipleSlots 使用多插槽时设置为true
  // styleIsolation 设置样式的隔离方式
  options: {
    multipleSlots: true
  },
  // ------- 外界给组件传入额外的样式 ---------
  externalClasses: [],
  // ------- 可以监听properties/data的改变 ---------
  observers: {
    counter: function(newVal) {
      console.log(newVal);
    }
  }
})
```
##### 生命周期
```
Component({
  // ------- 组件中监听生命周期函数 ---------
  // 1.监听所在页面的生命周期
  pageLifetimes: {
    show() {
      console.log('监听组件所在页面显示出来时');
    },
    hide() {
      console.log('监听组件所在页面隐藏起来时');
    },
    resize() {
      console.log('监听页面尺寸改变');
    }
  },
  // 2.监听组件本身的生命周期
  lifetimes: {
    created() {
      console.log('组件被创建出来时');
    },
    attached() {
      console.log('组件被添加到页面');
    },
    ready() {
      console.log('组件被渲染出来时');
    },
    moved() {
      console.log('组件被移动到另一个节点');
    },
    detached() {
      console.log('组件被移除掉时');
    }
  }
})
```
### 小程序系统API
#### 网络请求
##### 网络请求-基本使用
- 微信提供了专属的API接口，用于网络请求：wx.request(Object object)

属性|类型|默认值|必填|说明|最低版本
---|---|---|---|---|---|
url|string||是|开发者服务器接口地址|
data|string/object/ArrayBuffer| |否|请求的参数|	
header|Object| |否|设置请求的header，header中不能设置Referer。content-type默认为application/json|	
timeout|number| |	否|超时时间，单位为毫秒|2.10.0
method|string|GET|否|HTTP请求方法|
dataType|string|json|否|返回的数据格式|
responseType|string|text|否|响应的数据类型|1.7.0
enableHttp2|boolean|false|否|开启http2|2.10.4
enableQuic|boolean|false|否|开启quic|2.10.4
enableCache|boolean|false|否|开启cache|2.10.4
success|function|	|否|接口调用成功的回调函数|
fail|function|	|否|接口调用失败的回调函数|
complete|function| |否|接口调用结束的回调函数（调用成功、失败都会执行|
  ```
    // 1.发送最简单的get请求
    wx.request({
      url: 'http://114.55.90.2:9001/api/finance/product',
      success: function(res) {
        console.log(res);        
      }
    })
    // 2.get请求，但是携带参数
    wx.request({
      url: 'http://114.55.90.2:9001/api/finance/product',
      data: {
        province: '江苏省',
        city: '宿迁市'
      },
      success: function(res) {
        console.log(res);        
      }
    })
    // 3.post请求，并且携带参数
    wx.request({
      url: 'http://httpbin.org/post',
      method: 'POST',
      data: {
        name: 'coderwhy',
        age: 18
      },
      success: function(res) {
        console.log(res);        
      },
      fail: function(err) {
        console.log(err);
      }
    })
  ```
##### 网络请求-请求封装
```
export default function request(options) {
  return new Promise((resolve, reject) => {
    wx.request({
      url: options.url,
      method: options.method || 'GET',
      data: options.data || {},
      success: resolve,
      fail: reject
    })
  })
}
// export default function request(options) {
//   return new Promise((resolve, reject) => {
//     wx.request({
//       url: options.url,
//       method: options.method || 'GET',
//       data: options.data || {},
//       success: (result) => {
//         resolve(result)
//       },
//       fail: (res) => {
//         reject(res)
//       }
//     })
//   })
// }
```
#### 展示弹窗
- 小程序中展示弹窗有四种方式：showToast、showModal、showLoading、showActionSheet
##### showToast
- 参考文档：https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html
```
wx.showToast({
  title: '加载中',
  duration: 3000,
  icon: 'loading',
  mask: true,
  // image: "图片路径"
  success: function () {
    console.log('展示弹窗成功');
  },
  fail: function () {
    console.log('展示弹窗失败');
  },
  complete: function () {
    console.log('展示弹窗完成');
  }
})
```
##### showModal
- 参考文档：https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showModal.html
```
wx.showModal({
  title: '我是标题',
  content: '我是内容',
  // showCancel: false,
  cancelText: '退出',
  cancelColor: 'red',
  success: function(res) {
    console.log(res);
    if(res.cancel) {
      console.log('用户点击了取消按钮');
    }
    if(res.confirm) {
      console.log('用户点击了确定按钮');
    }
  }
})
```
##### showLoading
- 参考文档：https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showLoading.html
```
wx.showLoading({
  title: '加载ing', 
  mask: true
})
setTimeout(()=>{
  // 隐藏loading
  wx.hideLoading()
}, 2000)
```
##### showActionSheet
- 参考文档：https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showActionSheet.html
```
wx.showActionSheet({
  itemList: ['相册', '拍照'],
  itemColor: 'red',
  success: function(res) {
    console.log(res); // tapIndex
  }
})
```
#### 页面分享
- 分享是小程序扩散的一种重要方式，小程序有两种分享方式：
##### 点击右上角的菜单按钮，之后点击转发
- 自定义转发内容 基础库 2.8.1 起，分享图支持云图片。

字段|说明|默认值|最低版本
---|---|---|---|
title	|转发标题|	当前小程序名称|	
path|	转发路径|	当前页面 path ，必须是以 / 开头的完整路径|
imageUrl|	自定义图片路径，可以是本地文件路径、代码包文件路径或者网络图片路径。支持PNG及JPG。显示图片长宽比是 5:4。|使用默认截图|	1.5.0

```
  // pages/home/home.js
  Page({
    onShareAppMessage(options) {
      console.log(options);
      return {
        title: '你好啊，你银河',
        path: '/pages/about/about',
        imageUrl: 'http://attach.bbs.miui.com/forum/201401/22/134002dhye9qe2g2nq2geu.jpg'
      }
    }
  })
```
##### 点击某一个按钮直接转发
```
  <!--pages/home/home.wxml-->
  <!-- 5.分享按钮 -->
  <button size="mini" open-type="share">分享</button>
```
#### 小程序的登录流程
##### 登录流程时序
![](https://github.com/wanghuan19961020/study-notes/blob/master/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.jpg)
1. 调用wx.login获取code
2. 调用wx.request发送code到我们自己的服务器（我们自己的服务器会返回一个登录态的标识，比如token）
3. 将登录态的标识token进行存储，以便下次使用
4. 请求需要登录态标识的接口时，携带token
##### 登录代码实练
```
// app.js
const TOKEN = 'token'
App({
  globalData: {
    token: ''
  },
  onLaunch: function () {
    // 1.先从缓存中取出token
    const token = wx.getStorageSync(TOKEN)
    // 2.判断token是否有值
    if(token && token.length !==0 ) { // 已有token，判断token是否过期
      this.check_token(token) // 验证token是否过期
    } else { // 没有token，进行登录操作
      this.login()
    }
  },
  check_token(token) {
    console.log('执行了验证token操作');
    wx.request({
      url: 'http://123.207.32.32:3000/auth',
      method: "POST",
      header: {
        token
      },
      success: (res) => {
        if(!res.data.errCode) {
          console.log('token有效');  
          this.globalData.token = token
        } else {
          this.login()
        }      
      }
    })
  },
  login() {
    console.log('执行了登录操作');    
    // 登录操作
    wx.login({
      // code只有5min的有效期
      success: (res) => {
        // 1.获取code
        const code = res.code
        // 2.将code发送给我们的服务器
        wx.request({
          url: 'http://123.207.32.32:3000/login',
          method: "POST",
          data: {
            code
          },
          success: (res) => {
            // 1.取出token
            const {
              token
            } = res.data
            // 2.将token保存在globalData中
            this.globalData.token = token
            // 3.进行本地存储
            wx.setStorageSync(TOKEN, token)
          }
        })
      }
    })
  }
})
```
```
// pages/home/home.js
const app = getApp()
Page({
  onReady: function () {
    const { token } = app.globalData
    console.log(token);
  }
})
```
#### 界面跳转
- 界面跳转有两种方式：**通过navigator组件**和**通过wx的API跳转**
##### navigator组件
属性|类型|默认值|必填|说明|最低版本
---|---|---|---|---|---|
target|string|self|否|在哪个目标上发生跳转，默认当前小程序|2.0.7
url|string|	|否|当前小程序内的跳转链接|1.0.0
open-type|string|navigate|否|跳转方式|1.0.0
delta	|number|1|否|当open-type为'navigateBack'时有效，表示回退的层数|1.0.0

- open-type 的合法值

值|说明|最低版本
---|---|---|
navigate|对应wx.navigateTo或wx.navigateToMiniProgram的功能|	
redirect|对应wx.redirectTo的功能|	
switchTab|对应wx.switchTab的功能|	
reLaunch|对应wx.reLaunc的功能|1.1.0
navigateBack|对应wx.navigateBack的功能|1.1.0
exit|退出小程序，target="miniProgram"时生效|2.1.0
```
<!--pages/home/home.wxml-->
<!-- 1.navigator页面跳转 -->
<navigator url="/pages/detail/detail">跳到详情页</navigator>
<!-- 2.navigator属性：open-type -->
<navigator 
  url="/pages/detail/detail"
  open-type="redirect"
>
	跳到详情页(redirect)
</navigator>
<navigator 
  url="/pages/about/about"
  open-type="switchTab"
>
	跳到关于页(switchTab)
</navigator>
<navigator 
  url="/pages/detail/detail"
  open-type="reLaunch"
>
	跳到详情页(reLaunch)
</navigator>
```
```
// app.json
{
  "pages": [
    "pages/home/home",
    "pages/about/about",
    "pages/detail/detail",
    "pages/comment/comment"
  ],
  "tabBar": {
    "list": [{
        "pagePath": "pages/home/home",
        "text": "首页"
      },
      {
        "pagePath": "pages/about/about",
        "text": "关于"
      }
    ]
  }
}
```
```
<!--pages/detail/detail.wxml-->
<text>pages/detail/detail.wxml</text>
<navigator url="/pages/comment/comment">跳到评论页</navigator>
<navigator open-type="navigateBack">返回</navigator>
```
```
<!--pages/comment/comment.wxml-->
<text>pages/comment/comment.wxml</text>
<navigator open-type="navigateBack" delta="2">返回首页</navigator>
```
- 数据传递-传递过程
  1. 首页->详情页：
      - 通过修改URL传递参数
  2. 详情页->首页：
      - 在onUnload中修改数据
      - 通过getCurrentPages来获取所有的页面，然后使用页面对象的setData({})函数来修改
```
<!--pages/home/home.wxml-->
<!-- 3.跳转过程中数据的传递 -->
<navigator 
  url="/pages/detail/detail?name=why&age=18&height=1.88"
>
	跳到详情页
</navigator>
<view>{{title}}</view>
```
```
// pages/home/home.js
Page({
  data: {
    title: '哈哈哈哈'
  }
})
```
```
// pages/detail/detail.js
Page({
  onLoad: function (options) {
    console.log(options);  // 通过options接收上一个页面url参数里携带的数据
  },
  onUnload() {
    // console.log('页面退出'); 
    // 1.获取首页的页面对象 
    // getCurrentPages当前栈里的所有页面
    const pages = getCurrentPages()
    const home = pages[pages.length - 2]
    // 2.调用页面对象的setData
    home.setData({
      title: '呵呵呵'
    })
  }
})
```
##### 代码的跳转和返回
```
<!--pages/home/home.wxml-->
<!-- 4.通过代码进行页面跳转 -->
<button size="mini" bindtap="handlePushDetail">跳到详情页</button>
```
```
// pages/home/home.js
Page({
  handlePushDetail() {
    wx.navigateTo({
      url: '/pages/detail/detail?title=你好啊',
    })
  }
})
```
```
<!--pages/detail/detail.wxml-->
<text>pages/detail/detail.wxml</text>
<button size="mini" bindtap="handleBackHome">返回</button>
```
```
// pages/detail/detail.js
Page({
  handleBackHome() {
    wx.navigateBack({
      delta: 1,
    })
  }
})
```
- wx.switchTab(Object object)：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
- wx.reLaunch(Object object)：关闭所有页面，打开到应用内的某个页面
- wx.redirectTo(Object object)：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。
- wx.navigateTo(Object object)：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈最多十层。
- wx.navigateBack(Object object)：关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。
- 官方参考：https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html

